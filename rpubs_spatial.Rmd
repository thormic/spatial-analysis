---
title: "Spatial analysis of Kensington and Chelsea district in London (on OA level) - including house prices."
author: "Bartlomiej Kowalczuk & Michal Thor"
date: "13 06 2020"
output: html_document
---


```{r setup, include=FALSE}

source("load_libraries.R")
```

# Spatial analysis of Kensington and Chelsea district in London (on Output Areas [OA] level) - including house prices.

## Short decription:
In this project we conducted spatial analysis of Kensington and Chelsea district (later referred to as K&D) in London. We used data from:
- [Nomis site](https://www.nomisweb.co.uk/query/select/getdatasetbytheme.asp?opt=3&theme=&subgrp=)
-- We used data from 2011 Census on OA level (lowest division). All the data was downloaded in percentages
- [HM Land Registry](https://landregistry.data.gov.uk/app/ppd/)
-- We used data for house sales made in Kensington and Chelsea district in 2011


## Context
We chose Kensington and Chelsea district for our analysis because we thought it is one of the most "mixed" districts in London. It is the smallest borough in London and the second smallest district in England; it is one of the most densely populated administrative regions in the United Kingdom. It also includes affluent areas such as Notting Hill, Kensington, South Kensington, Chelsea, and Knightsbridge. The fact that it contains many of the most expensive residential properties in the world may show some distinct social inequalities. At the 2011 census, the borough had a population of 158,649 who were 71% White, 10% Asian, 5% of multiple ethnic groups, 4% Black African and 3% Black Caribbean. A 2017 study by Trust for London and the New Policy Institute found that Kensington & Chelsea has the greatest income inequality of any London Borough. Private rent for low earners was also found to be the least affordable in London. However, the borough's poverty rate of 28% is roughly in line with the London-wide average.

All these factors convinced us that more in-depth analysis of that district might result in some insightful outcomes.


## Hypothesis
In further analysis we decided to verify 2 major hypotheses:
- Employed indicator does differ among different groups of OAs. We can explain it by using demographic factors both from this OA and from neighbouring ones using spatially lagged variables.
- Mean of house prices in OAs is affected by its' socio-economic structure as well as neighbouring OAs - introducing Geographically Weighted Regression improves the prediction accuracy.



## Loading the data
First, let us load the previously prepared data:
```{r load_data, echo=TRUE}

Census.Data <- read.csv("census_data.csv")
houseData <- read.csv("house_data.csv")

House.Points <-SpatialPointsDataFrame(houseData[,6:7], houseData,
                                      proj4string = CRS("+init=EPSG:27700"))

hist_df <- gather(Census.Data[,-1], key = "name", value = "value")

Output.Areas <- readOGR("data/statistical-gis-boundaries-london/ESRI", "OA_2011_London_gen_MHW")
Output.Areas <- Output.Areas[Output.Areas$LAD11NM=="Kensington and Chelsea",]

OA.Census <- merge(Output.Areas, Census.Data, by.y ="OA", by.x="OA11CD")
proj4string(OA.Census) <- CRS("+init=EPSG:27700")

House.Agg <- houseData %>%
  group_by(oa11) %>%
  dplyr::summarize(mean_price = mean(price_paid, na.rm=TRUE))

houses_merged <-  Census.Data %>%
  inner_join(House.Agg, by = c("OA" = "oa11"))

OA.Census.mp <- merge(Output.Areas, houses_merged, by.y ="OA", by.x="OA11CD", all = FALSE)
proj4string(OA.Census.mp) <- CRS("+init=EPSG:27700")
```

## Exploratory Data Analysis:

We use histograms to explore denisty of each variable, take a brief look into how the dataset looks like and check for any potential model variables in the further analysis.
```{r histograms, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

ggplot(hist_df) +
  geom_histogram(aes(value)) +
  facet_wrap(~name, ncol = 5) +
  ggtitle("Histograms of all variables")
```

```{r reset_plots, echo=FALSE, include=FALSE}
dev.off()
```

Now, let's check distribution of percentages across all OA's of religion-based variables, race-based and certain chosen variables.
```{r boxplot1, echo = FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

boxplot(Census.Data$christian, Census.Data$muslim, Census.Data$jewish,
        Census.Data$no_religion, ylim=c(0,100),
        col = "dodgerblue", rectCol="dodgerblue3", colMed="dodgerblue4",
        names=c("Christian", "Muslim", "Jewish", "No religion"),
        main = "Distribution of religions per OA")
```
We can see that the majority of inhabitants of K&D are christian - however there are many outliers in muslim religion meaning that there could be heavy muslim-biased OA districts in K&D.
```{r boxplot2, echo = FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}
boxplot(Census.Data$white, Census.Data$black_african, Census.Data$asian,
        Census.Data$other_arab, ylim=c(0,100),
        col = "dodgerblue", rectCol="dodgerblue3", colMed="dodgerblue4",
        names=c("White people", "Black/African", "Asian", "Other/Arabs"),
        main = "Distribution of race per OA")
```
Once again, there is one overwhelming group - white people, but there are few outliers in every religion, therefore meaning again that we might have some districts that would greatly differ from the rest.
```{r boxplot3, echo = FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}
boxplot(Census.Data$employed, Census.Data$unemployed, Census.Data$kids_english, Census.Data$male, Census.Data$white,
        Census.Data$Age_30_44, Census.Data$married, Census.Data$owned,  ylim=c(0,100),
        col = "dodgerblue", rectCol="dodgerblue3", colMed="dodgerblue4",
        names=c("Employed", "Unemployed", "Kids speaking english", "Male", "White people", "Age 30-44", "Married", "Property owned"),
        main = "Distribution of certain variables per OA")

```
Finally, looking at the distribution of chosen variables, we can see that there are for example OA's with very low employment rate or rather high percentage of families where only children under age of 6 have English as their primiary language, so we expect (considering previous two boxplots) that whole K&D might be divised into wealthy areas, poor areas, areas mostly occupied by immigrants and religious based areas. That is a good starting point for further spatial analysis.

Now let us explore dependencies between some variables that we would expect to be somehow correlated. We can see that on scatterplots below:
```{r scatterplots, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

# Scatterplots with regression line

p <- ggplot(Census.Data, aes(unemployed, highest_quali))
p + geom_point(aes(colour = muslim, size = black_african)) 

p2 <- ggplot(Census.Data, aes(highest_quali, employed))
p2 + geom_point(aes(colour = white, size = other_eu))

```
Looking at the first one we can see that there is a negative correlation between percentage of highest qualification within OA and the unemployment rate. Additionally OA's with more black/african people and of muslim faith are mostly the ones with highest unemployment rate. That indicates that there might be a problem in employment opportunities and education for immigrants. 

On the second one the correlation between being employment rate and percentage of inhabitants with highest qualification is rather positive. However, what is interesting is that OA's with the most qualified and highest employment rate are also the ones with the most white people from european countries other than United Kingdom. That might raise suspicion, that there might be racial problem for immigrants - it is far easier for you to get education and employment if you are white. One would argue that many students from across Europe aspire to study/work in London, so this might also create the bias. However this thesis is not supported by gathered data.

Correlation plot:
```{r correlation, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

# Correlation plot

M<-cor(Census.Data[,-1])
corrplot(M, type="upper", order="hclust",
         col=brewer.pal(n=8, name="RdYlBu"))
```
Variables that we expected to be correlated with each other matched the expectations. Most of the non-white non-native OA's are also the ones with most social rented flats, biggest unemployment rate and with lowest qualification.

Now we will explore how percentages of citizens with highest qualification, of black/african or white race distribute among OAs. All plots are interactive, so we can analyze it also with reference to the geographical location.
```{r var_maps, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

# Maps with filling 
tmap_mode("view")

tm_shape(OA.Census) + tm_fill("highest_quali", palette = "Purples", style = "quantile",
                              title = "% with a highest Qualifications") + tm_borders(alpha=.4)

tm_shape(OA.Census) + tm_fill("black_african", palette = "YlGn", style = "quantile",
                              title = "% of Black/African") + tm_borders(alpha=.4)

tm_shape(OA.Census) + tm_fill("muslim", palette = "GnBu", style = "quantile",
                              title = "% of Muslim") + tm_borders(alpha=.4)

tm_shape(OA.Census) + tm_fill("white", palette = "PuBu", style = "quantile",
                              title = "% of White") + tm_borders(alpha=.4)

tm_shape(OA.Census) + tm_fill("united_kingdom", palette = "PuBu", style = "quantile",
                              title = "% of born in UK") + tm_borders(alpha=.4)
```
As we previously expected - OAs with highest densities of black/africans are also packed with people of muslim faith. On the contrary, areas with mostly white people are also the ones with highest rate of highly qualified citizens. We can also see that OAs in north of the district (North Kensington mostly) are visibly apart from the center and south (Chelsea) which is mostly occupied by natives.

However, what is truly remarkable, OAs with most people born in UK are also the ones having the most of the black/african people. So where do these highly qualified white people residing in south come from?


Let us explore how prices of houses in K&D compare with distribution of citizens that were born in EU countries:
```{r price_var_maps, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

# Plot maps with house prices and variables
tm_shape(OA.Census) + tm_fill("other_eu", palette = "Greens",
                              style = "quantile", title = "% Whites") +
  tm_borders(alpha=.4) +
  tm_shape(House.Points) + tm_bubbles(col = "price_paid", size = 0.2,
                                      palette = "Blues", style = "quantile",
                                      legend.size.show = FALSE,
                                      title.col = "Price Paid (£)",
                                      border.col = "black", border.lwd = 0.1,
                                      border.alpha = 0.1) +
  tm_layout(legend.text.size = 0.8, legend.title.size = 1.1, frame = FALSE)


tm_shape(OA.Census) + tm_fill("unemployed", palette = "Oranges",
                              style = "quantile", title = "% Unemployed") +
  tm_borders(alpha=.4) +
  tm_shape(House.Points) + tm_bubbles(col = "price_paid", size = 0.2,
                                      palette = "Blues", style = "quantile",
                                      legend.size.show = FALSE,
                                      title.col = "Price Paid (£)",
                                      border.col = "black", border.lwd = 0.1,
                                      border.alpha = 0.1) +
  tm_layout(legend.text.size = 0.8, legend.title.size = 1.1, frame = FALSE)

```
So, there is the answer - those mostly-white OAs with high rate of qualification are the areas occupied mostly by EU born citizens. Prices in these areas are also much higher. We added distribution of unemployment - both to show that it overlaps with the previous north areas and it is negatively correlated with prices. We expect that there might not be direct cause and effect - it is probably more of a vicious cycle.


```{r load_kernels, echo=FALSE, warning=FALSE, message=FALSE}

kde.output <- kernelUD(House.Points, h="href", grid = 1000)
kde <- raster(kde.output)
projection(kde) <- CRS("+init=EPSG:27700")
tmap_mode("plot")
bounding_box <- bbox(Output.Areas)
masked_kde <- mask(kde, Output.Areas)
```

```{r kernel_density, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

tm_shape(masked_kde, bbox = bounding_box) + tm_raster("ud", style = "quantile",
                                                      n = 100,
                                                      legend.show = FALSE,
                                                      palette = "YlGnBu") +
  tm_shape(Output.Areas) + tm_borders(alpha=.3, col = "white") +
  tm_layout(frame = FALSE) 

range75 <- getverticeshr(kde.output, percent = 75)
range50 <- getverticeshr(kde.output, percent = 50)
range25 <- getverticeshr(kde.output, percent = 25)

tm_shape(Output.Areas) + tm_fill(col = "#f0f0f0") + tm_borders(alpha=.8, col = "white") +
  tm_shape(House.Points) + tm_dots(col = "blue") +
  tm_shape(range75) + tm_borders(alpha=.7, col = "#fb6a4a", lwd = 2) +
tm_fill(alpha=.1, col = "#fb6a4a") +
  tm_shape(range50) + tm_borders(alpha=.7, col = "#de2d26", lwd = 2) +
  tm_fill(alpha=.1, col = "#de2d26") +
  tm_shape(range25) + tm_borders(alpha=.7, col = "#a50f15", lwd = 2) +
  tm_fill(alpha=.1, col = "#a50f15") +
  tm_layout(frame = FALSE)

```
From density plots we can see that houses in the "richest" OAs are also ares with most houses sold/highest rotation.


## Model part

In this part we are going to focus our study on the causes of the size of the employment rate as well as the housing prices in the Royal Borough of Kensington and Chelsea.

Firstly, we need to compute polygons for our dataset, which we are going to use in later parts of the study. Doing this in two different ways results in:

```{r neighbours, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# ------------------- Finding neighbours -------------------

neighbours <- poly2nb(OA.Census)
neighbours2 <- poly2nb(OA.Census, queen = FALSE)

plot(OA.Census, border = 'lightgrey')
plot(neighbours, coordinates(OA.Census), add=TRUE, col='blue')
plot(neighbours2, coordinates(OA.Census), add=TRUE, col='red')
```

## Global Spatial Autocorrelation

Having the neighbours computed, we can ran Moran's test, which will result in correlation score for our employed variable.

Moran I Test:
```{r global_autocorr, echo=FALSE, warning=FALSE}

# ------------------- Running a global spatial autocorrelation -------------------
listw <- nb2listw(neighbours2)
moran.test(OA.Census$employed, listw)
```

Employed indicator has 0.34 Moran's I statistic so it has a slight positive autocorrelation. Now, we have reasons to believe that the data does spatially cluster.

## Local Spatial Autocorrelation

Analysis of the local spatial autocorrelation may result in broader conclusions. 

Below, you can observe local moran statistic on our map broken down by OA:

```{r local_autocorr, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# ------------------- Running a local spatial autocorrelation -------------------

# Moran output for local 
local <- localmoran(x = OA.Census$employed,
                    listw = nb2listw(neighbours2, style = "W"))
moran.map <- cbind(OA.Census, local)
tm_shape(moran.map) + tm_fill(col = "Ii", style = "quantile", palette = "GnBu", title = "local moran statistic") + tm_layout(frame = FALSE)

```

We can clearly see that there are indeed areas, which are surrounded by units with similar values - those with positive local moran statistic. This further confirms that the data spatially cluster. However, this map does not bring us specific information about those areas/clusters.

To get the insights of each one, we are going to utilize LISA cluster map.

## LISA cluster map

We set the level of significance to 0.2 for quality visualizations.
```{r lisa, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# -------------------  to create LISA cluster map ------------------- 

quadrant <- vector(mode="numeric",length=nrow(local))
m.employed <- OA.Census$employed - mean(OA.Census$employed)
m.local <- local[,1] - mean(local[,1])
# Set significance threshold
signif <- 0.2
# Data quadrants
quadrant[m.employed >0 & m.local>0] <- 4
quadrant[m.employed <0 & m.local<0] <- 1
quadrant[m.employed <0 & m.local>0] <- 2
quadrant[m.employed >0 & m.local<0] <- 3
quadrant[local[,5]>signif] <- 0

brks <- c(0,1,2,3,4)
colors <- c("white","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
plot(OA.Census,border="lightgray",col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
legend("bottomleft",legend=c("insignificant","low-low","low-high","high-low","high-high"),
       fill=colors,bty="n")
```
We can now observe, which clusters are of high and which of low values. North areas of Kensington have mostly low employment rates however they border with areas of high values (hence light blue color), while some of the Chelsea's areas with high employment rates border with low values (hence light red), even though these are in the center of Chelsea. Additionally we can see a few clusters of high-high and low-low (strong red/blue color) - these are areas bordering with other similar to them in terms of employment. We can conclude, that the data is significantly clustered in means of employment.


## GETIS-ORD

We can also check whether the Getis-Ord Gi statistic can help us with our analysis. Thanks to that we can broaden our analysis with proximity based neighbours instead of border based.

We set the proximity to 750 meters (which emphasize clusters most efficiently) and observe hot-spots based on intenisty of clusters, on the map below:
```{r getis_ord, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# -------------------  GETIS-ORD ------------------- 

nb <- dnearneigh(coordinates(OA.Census),0,750)
nb_lw <- nb2listw(nb, style = 'B')


# Gi statistic
local_g <- localG(OA.Census$employed, nb_lw)
local_g <- cbind(OA.Census, as.matrix(local_g))
names(local_g)[58] <- "gi_statistic"

tm_shape(local_g) + tm_fill("gi_statistic", palette = "-RdBu", style = "pretty") +
  tm_borders(alpha=.4) + tm_layout(frame = FALSE)
```
We can clearly see that there are three main clusters:
- of low values in the north
- of high values in the center
- of slightly high values in the south

Let's see if we can infer more from regression models and explain the employment rate.

## Linear model - employment rate

We will start with the OLS model.

Using backward variable selection we eliminated most of the insignificant variables and came up with following model:
```{r linear_model, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# -------------------  LINEAR MODEL ------------------- 

sig_cols_2 <- c('white', 'black_african', 'single', 'lowest_quali','highest_quali')
model_sig_2 <- lm(OA.Census$employed ~ .-1, data = OA.Census[,sig_cols_2])
summary(model_sig_2)

par(mfrow=c(2,2))
plot(model_sig_2)
```
We obtain almost ideally fitted model, with R-squared = 0.99. It means that the variables that we chose explain it very accurately. We can further explore the coefficients- all of them are positive, however qualifications level is the strongest one. Indicator that people live alone being the weakest. We can also observe that both white and black races, surprisingly considering previous data explorations, impact the employed indicator in almost the same way.

Let's see if residuals vary among different OAs.

```{r linear_model_resids, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}
resids<-residuals(model_sig_2)
map.resids <- cbind(OA.Census, resids)
names(map.resids)[58] <- "resids"

tm_shape(map.resids) + tm_fill("resids", palette="Blues") + tm_borders(alpha=.4) + tm_layout(frame = FALSE)
```

There are no significant patterns, so we may expect that there are no variables that are unobserved in our analysis. However, spatial analysis using Geographically Weighted Regression (GWR) may bring more information.

## GWR - employment rate

We start with calculating kernel bandwith for GWR computation.
```{r gwr_adapt, include=False}
GWRbandwidth <- gwr.sel(OA.Census$employed ~ .-1, data = OA.Census[,sig_cols_2], adapt =TRUE)
```

```{r gwr, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# ------------------- GWR ------------------- 

gwr.model = gwr(OA.Census$employed ~ .-1,
                data = OA.Census[,sig_cols_2], adapt=GWRbandwidth, hatmatrix=TRUE, se.fit=TRUE)
gwr.model
```

R-squared seems to be much lower, let's see how it looks in division to the areas. 

```{r gwr_r2local, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}
results <-as.data.frame(gwr.model$SDF)
gwr.map <- cbind(OA.Census[,sig_cols_2], as.matrix(results))

tm_shape(gwr.map) + tm_fill("localR2", palette="PuBuGn")+ tm_borders(alpha=.4) + tm_layout(frame = FALSE)
```

It seems that the model is best fitted to the areas in the north, where the local R-squared is the highest.

Same as in the linear model, all coefficients are positive. We can further explore them divided among OAs.
```{r gwr_results, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}
# create tmap objects
map1 <- tm_shape(gwr.map) + tm_fill("white", n = 5, style = "quantile", palette="Blues",
                                    title = "white") +
 tm_layout(frame = FALSE)
map2 <- tm_shape(gwr.map) + tm_fill("white.1", n = 5, style = "quantile", palette="Greens",
                                    title = "white coefficient") +
  tm_layout(frame = FALSE)
map3 <- tm_shape(gwr.map) + tm_fill("black_african", n = 5, style = "quantile", palette="Blues",
                                    title = "black") +
  tm_layout(frame = FALSE)
map4 <- tm_shape(gwr.map) + tm_fill("black_african.1", n = 5, style = "quantile", palette="Greens",
                                    title = "black coefficient") +
  tm_layout(frame = FALSE)
map5 <- tm_shape(gwr.map) + tm_fill("single", n = 5, style = "quantile", palette="Blues",
                                    title = "single") +
  tm_layout(frame = FALSE)
map6 <- tm_shape(gwr.map) + tm_fill("single.1", n = 5, style = "quantile", palette="Greens",
                                    title = "single coefficient") +
  tm_layout(frame = FALSE)
map7 <- tm_shape(gwr.map) + tm_fill("lowest_quali", n = 5, style = "quantile", palette="Blues",
                                    title = "lowest qualifications") +
  tm_layout(frame = FALSE)
map8 <- tm_shape(gwr.map) + tm_fill("lowest_quali.1", n = 5, style = "quantile", palette="Greens",
                                    title = "lowest qualifications coefficient") +
  tm_layout(frame = FALSE)
map9 <- tm_shape(gwr.map) + tm_fill("highest_quali", n = 5, style = "quantile", palette="Blues",
                                    title = "highest qualifications") +
  tm_layout(frame = FALSE)
map10 <- tm_shape(gwr.map) + tm_fill("highest_quali.1", n = 5, style = "quantile", palette="Greens",
                                    title = "highest qualifications coefficient") +
  tm_layout(frame = FALSE)

# --- FIRST 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map1, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map2, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map3, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map4, vp=viewport(layout.pos.col = 2, layout.pos.row =2))

# --- SECOND 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map5, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map6, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map7, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map8, vp=viewport(layout.pos.col = 2, layout.pos.row =2))

# --- LAST VARIABLE
grid.newpage()
pushViewport(viewport(layout=grid.layout(1,2)))
print(map9, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map10, vp=viewport(layout.pos.col = 2, layout.pos.row =1))

```
Coefficients based on race turned out to impact north-center areas the most. Similarly with qualifications - south part, mainly Chelsea is impacted in almost the same way with lowest and highest qualifications.

Let's see how the models will predict the aggregated by the OA, mean house prices.

## LINEAR MODEL - PRICES

We will work through the same methodology as with the employed indicator.

Using backward variables selection we eliminated most of the insignificant variables and came up with following model:

```{r linear_price, echo=FALSE, warning=FALSE}

# -------------------  LINEAR MODEL - PRICE ------------------- 
sig_cols <- c( 'single', 'muslim','highest_quali', 'jewish', 'asian', 'one_car', 'no_cars',
               'Age_30_44', 'employed', 'private_rent')
model_sig <- lm(OA.Census.mp$mean_price ~ ., data = OA.Census.mp[sig_cols])
summary(model_sig)

```

On this target variable, the model is not that well-fitted, its R-squared equals to 0.399. It is interesting that the percentage of Jews impacts the average price the most postively, while having one car or no car the most negatively. The intercept estimates to over 6 million. Let's check the residuals on each of the OAs.

```{r linear_price_resids, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}
# plot resids
resids<-residuals(model_sig)
map.resids <- cbind(OA.Census.mp, resids)
names(map.resids)[58] <- "resids"
tm_shape(map.resids) + tm_fill("resids", palette="Blues") + tm_borders(alpha=.4) + tm_layout(frame = FALSE)
```

There are no patterns to the residuals, so we may conclude that we did not omit any significant variable in our modelling process.

Maybe, GWR model will bring more value.

## GWR - PRICES

```{r gwr_band, echo=FALSE, warning=FALSE, include=FALSE}

#calculate kernel bandwidth
GWRbandwidth <- gwr.sel(OA.Census.mp$mean_price ~ ., data = OA.Census.mp[,sig_cols], adapt =TRUE)
```

```{r gwr_price, echo=FALSE, warning=FALSE}

# ------------------- GWR - PRICE ------------------- 

gwr.model = gwr(OA.Census.mp$mean_price ~ .,
                data = OA.Census.mp[,sig_cols], adapt=GWRbandwidth, hatmatrix=TRUE, se.fit=TRUE)
#print the results of the model
gwr.model

```

This time, R-squared is higher than in the linear model - local R-squared can be observed on the plot below:

```{r gwr_localr22, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}
results <-as.data.frame(gwr.model$SDF)
gwr.map <- cbind(OA.Census.mp[,sig_cols], as.matrix(results))
tm_shape(gwr.map) + tm_fill("localR2", palette="PuBuGn")+ tm_borders(alpha=.4) + tm_layout(frame = FALSE)
```

Let's further explore the results plotting each variable and its coefficients.

```{r gwr_price_results, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# create tmap objects
map1 <- tm_shape(gwr.map) + tm_fill("single", n = 5, style = "quantile", palette="Greens",
                                    title = "single") +
  tm_layout(frame = FALSE)
map2 <- tm_shape(gwr.map) + tm_fill("single.1", n = 5, style = "quantile", palette="Blues",
                                    title = "single coefficient") +
  tm_layout(frame = FALSE)
map3 <- tm_shape(gwr.map) + tm_fill("muslim", n = 5, style = "quantile", palette="Greens",
                                    title = "muslim") +
  tm_layout(frame = FALSE)
map4 <- tm_shape(gwr.map) + tm_fill("muslim.1", n = 5, style = "quantile", palette="Blues",
                                    title = "muslim coefficient") +
  tm_layout(frame = FALSE)

map5 <- tm_shape(gwr.map) + tm_fill("jewish", n = 5, style = "quantile", palette="Greens",
                                    title = "jewish") +
  tm_layout(frame = FALSE)
map6 <- tm_shape(gwr.map) + tm_fill("jewish.1", n = 5, style = "quantile", palette="Blues",
                                    title = "jewish coefficient") +
  tm_layout(frame = FALSE)
map7 <- tm_shape(gwr.map) + tm_fill("asian", n = 5, style = "quantile", palette="Greens",
                                    title = "asian") +
  tm_layout(frame = FALSE)
map8 <- tm_shape(gwr.map) + tm_fill("asian.1", n = 5, style = "quantile", palette="Blues",
                                    title = "asian coefficient") +
  tm_layout(frame = FALSE)
map9 <- tm_shape(gwr.map) + tm_fill("one_car", n = 5, style = "quantile", palette="Greens",
                                    title = "one_car") +
  tm_layout(frame = FALSE)
map10 <- tm_shape(gwr.map) + tm_fill("one_car.1", n = 5, style = "quantile", palette="Blues",
                                     title = "one_car coefficient") +
  tm_layout(frame = FALSE)

map11 <- tm_shape(gwr.map) + tm_fill("no_cars", n = 5, style = "quantile", palette="Greens",
                                    title = "no_cars") +
  tm_layout(frame = FALSE)
map12 <- tm_shape(gwr.map) + tm_fill("no_cars.1", n = 5, style = "quantile", palette="Blues",
                                    title = "no_cars coefficient") +
  tm_layout(frame = FALSE)
map13 <- tm_shape(gwr.map) + tm_fill("Age_30_44", n = 5, style = "quantile", palette="Greens",
                                     title = "Age_30_44") +
  tm_layout(frame = FALSE)
map14 <- tm_shape(gwr.map) + tm_fill("Age_30_44.1", n = 5, style = "quantile", palette="Blues",
                                     title = "Age_30_44 coefficient") +
  tm_layout(frame = FALSE)
map15 <- tm_shape(gwr.map) + tm_fill("employed", n = 5, style = "quantile", palette="Greens",
                                     title = "employed") +
  tm_layout(frame = FALSE)
map16 <- tm_shape(gwr.map) + tm_fill("employed.1", n = 5, style = "quantile", palette="Blues",
                                     title = "employed coefficient") +
  tm_layout(frame = FALSE)
map17 <- tm_shape(gwr.map) + tm_fill("private_rent", n = 5, style = "quantile", palette="Greens",
                                     title = "private_rent") +
  tm_layout(frame = FALSE)
map18 <- tm_shape(gwr.map) + tm_fill("private_rent.1", n = 5, style = "quantile", palette="Blues",
                                     title = "private_rent coefficient") +
  tm_layout(frame = FALSE)
map19 <- tm_shape(gwr.map) + tm_fill("highest_quali", n = 5, style = "quantile", palette="Greens",
                                     title = "highest_quali") +
  tm_layout(frame = FALSE)
map20 <- tm_shape(gwr.map) + tm_fill("highest_quali.1", n = 5, style = "quantile", palette="Blues",
                                     title = "highest_quali coefficient") +
  tm_layout(frame = FALSE)


# --- FIRST 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map1, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map2, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map3, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map4, vp=viewport(layout.pos.col = 2, layout.pos.row =2))

# --- SECOND 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map5, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map6, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map7, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map8, vp=viewport(layout.pos.col = 2, layout.pos.row =2))


# --- THIRD 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map9, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map10, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map11, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map12, vp=viewport(layout.pos.col = 2, layout.pos.row =2))

# --- FOURTH 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map13, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map14, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map15, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map16, vp=viewport(layout.pos.col = 2, layout.pos.row =2))

# --- FIFTH 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map17, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map18, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map19, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map20, vp=viewport(layout.pos.col = 2, layout.pos.row =2))
```
- Having one car or not having a car at all impacts north areas in the same way. 
- 

## Interpolation

```{r interpolation, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# ------------------- Interpolation ------------------- 

# Create a tessellated surface
dat.pp <- as(dirichlet(as.ppp(House.Points)), "SpatialPolygons")
dat.pp <- as(dat.pp,"SpatialPolygons")
# Sets the projection to British National Grid
proj4string(dat.pp) <- CRS("+init=EPSG:27700")
proj4string(House.Points) <- CRS("+init=EPSG:27700")
# Assign to each polygon the data from House.Points
int.Z <- over(dat.pp,House.Points, fn=mean)
# Create a SpatialPolygonsDataFrame
thiessen <- SpatialPolygonsDataFrame(dat.pp, int.Z)
thiessen.crop <-crop(thiessen, Output.Areas)

# maps house prices across thiessen polygons
tm_shape(thiessen.crop) + tm_fill(col = "price_paid", style = "quantile", palette = "Blues",
                                  title = "Price Paid (£)") +
  tm_borders(alpha=.3, col = "black") +
  tm_shape(House.Points) + tm_dots(col = "black") +
  tm_layout(legend.position = c("left", "bottom"), legend.text.size = 1.05,
            legend.title.size = 1.2, frame = FALSE)
```

## Inverse distance weighting

```{r idw, echo=FALSE, warning=FALSE}

# ------------------- Inverse distance weighting ------------------- 

# define sample grid based on the extent of the House.Points file
grid <-spsample(House.Points, type = 'regular', n = 10000)
# runs the idw for the Price variable of House.Points
idw <- idw(House.Points$price_paid ~ 1, House.Points, newdata= grid)

idw.output = as.data.frame(idw)
names(idw.output)[1:3] <- c("long", "lat", "prediction")


spg <- idw.output
coordinates(spg) <- ~ long + lat
# coerce to SpatialPixelsDataFrame
gridded(spg) <- TRUE
# coerce to raster
raster_idw <- raster(spg)
# sets projection to British National Grid
projection(raster_idw) <- CRS("+init=EPSG:27700")
# we can quickly plot the raster to check its okay
# plot(raster_idw)
```

## 3D PLOTTING
```{r 3dplots, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8, message=FALSE}

# ------------------- 3D PLOTTING ------------------- 
persp(raster_idw)

idw2 <- as.matrix(raster_idw)
persp3d(idw2, col = "red")

# masks our raster by our output areas polygon file
masked_idw <- mask(raster_idw, Output.Areas)
# plots the masked raster
tm_shape(masked_idw) + tm_raster("prediction", style = "quantile", n = 100,
                                 legend.show = FALSE) +
  tm_shape(House.Points) + tm_bubbles(size = "price_paid", col = "price_paid",
                                      palette = "Blues", style = "quantile",
                                      legend.size.show = FALSE,
                                      title.col = "Price Paid (£)") +
  tm_layout(legend.position = c("left", "bottom"), legend.text.size = 1.1,
            legend.title.size = 1.4, frame = FALSE)
```

## Geostatistical interpolation
```{r geo_interpolation, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
# ------------------- Geostatistical interpolation ------------------- 
grid <-spsample(House.Points, type = 'regular', n = 10000)
# runs the kriging
kriging_result = autoKrige(log(price_paid)~1, House.Points, grid)
```

```{r geo_interpolation_plot, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8,}
plot(kriging_result)
```


## Conclusion

We concluded that there might be more of a wealth division rather than racial - although there are areas in which black/african people constitute for larger percentage of citizens, these are the same areas which have majority of native British citizens. However - there are very distinct areas which are dominated by people from EU with the highest qualifications therefore effecting in lowest unemployment rates. 
Immigrants, people of other race than white and people of other religion than christian tend to cluster into their own OAs, completly separate from regions that are mostly-white, rather rich and full of highly-educated citizens (which are less concentrated and there is no marked boundary)

