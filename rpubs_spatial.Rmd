---
title: "Spatial analysis of Kensington and Chelsea district in London (on OA level) - including house prices."
author: "Bartlomiej Kowalczuk & Michal Thor"
date: "13 06 2020"
output: html_document
---


```{r setup, include=FALSE}

source("load_libraries.R")
```

# Spatial analysis of Kensington and Chelsea district in London (on OA level) - including house prices.

## Short decription:
In this project we conducted spatial analysis of Kensington and Chelsea district (later referred to as K&D) in London. We used data from:
- [Nomis site](https://www.nomisweb.co.uk/query/select/getdatasetbytheme.asp?opt=3&theme=&subgrp=)
-- We used data from 2011 Census on OA level (lowest division). All the data was downloaded in percentages
- [HM Land Registry](https://landregistry.data.gov.uk/app/ppd/)
-- We used data for house sales made in Kensington and Chelsea district in 2011

## Context

## Hypothesis


## Loading the data:
First, let us load the previously prepared data:
```{r load_data, echo=TRUE}

Census.Data <- read.csv("census_data.csv")
houseData <- read.csv("house_data.csv")

House.Points <-SpatialPointsDataFrame(houseData[,6:7], houseData,
                                      proj4string = CRS("+init=EPSG:27700"))

hist_df <- gather(Census.Data[,-1], key = "name", value = "value")

Output.Areas <- readOGR("data/statistical-gis-boundaries-london/ESRI", "OA_2011_London_gen_MHW")
Output.Areas <- Output.Areas[Output.Areas$LAD11NM=="Kensington and Chelsea",]

OA.Census <- merge(Output.Areas, Census.Data, by.y ="OA", by.x="OA11CD")
proj4string(OA.Census) <- CRS("+init=EPSG:27700")

House.Agg <- houseData %>%
  group_by(oa11) %>%
  dplyr::summarize(mean_price = mean(price_paid, na.rm=TRUE))

houses_merged <-  Census.Data %>%
  inner_join(House.Agg, by = c("OA" = "oa11"))

OA.Census.mp <- merge(Output.Areas, houses_merged, by.y ="OA", by.x="OA11CD", all = FALSE)
proj4string(OA.Census.mp) <- CRS("+init=EPSG:27700")
```

## Exploratory Data Analysis:

We use histograms to explore denisty of each variable, take a brief look into how the dataset looks like and check for any potential model variables in the further analysis.
```{r histograms, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

ggplot(hist_df) +
  geom_histogram(aes(value)) +
  facet_wrap(~name, ncol = 5) +
  ggtitle("Histograms of all variables")
```

```{r reset_plots, echo=FALSE, include=FALSE}
dev.off()
```

Now, let's check distribution of percentages across all OA's of religion-based variables, race-based and certain chosen variables.
```{r boxplots, echo = FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

boxplot(Census.Data$christian, Census.Data$muslim, Census.Data$jewish,
        Census.Data$no_religion, ylim=c(0,100),
        col = "dodgerblue", rectCol="dodgerblue3", colMed="dodgerblue4",
        names=c("Christian", "Muslim", "Jewish", "No religion"),
        main = "Distribution of religions per OA")
```
We can see that the majority of inhabitants of K&D are christian - however there are many outliers in muslim religion meaning that there could be heavy muslim-biased OA districts in K&D.
```{r boxplots, echo = FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}
boxplot(Census.Data$white, Census.Data$black_african, Census.Data$asian,
        Census.Data$other_arab, ylim=c(0,100),
        col = "dodgerblue", rectCol="dodgerblue3", colMed="dodgerblue4",
        names=c("White people", "Black/African", "Asian", "Other/Arabs"),
        main = "Distribution of race per OA")
```
Once again, there is one overwhelming group - white people, but there are few outliers in every religion, therefore meaning again that we might have some districts that would greatly differ from the rest.
```{r boxplots, echo = FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}
boxplot(Census.Data$employed, Census.Data$unemployed, Census.Data$kids_english, Census.Data$male, Census.Data$white,
        Census.Data$Age_30_44, Census.Data$married, Census.Data$owned,  ylim=c(0,100),
        col = "dodgerblue", rectCol="dodgerblue3", colMed="dodgerblue4",
        names=c("Employed", "Unemployed", "Kids speaking english", "Male", "White people", "Age 30-44", "Married", "Property owned"),
        main = "Distribution of certain variables per OA")

```
Finally, looking at the distribution of chosen variables, we can see that there are for example OA's with very low employment rate or rather high percentage of families where only children under age of 6 have English as their primiary language, so we expect (considering previous two boxplots) that whole K&D might be divised into wealthy areas, poor areas, areas mostly occupied by immigrants and religious based areas. That is a good starting point for further spatial analysis.

Now let us explore dependencies between some variables that we would expect to be somehow correlated. We can see that on scatterplots below:
```{r scatterplots, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

# Scatterplots with regression line

p <- ggplot(Census.Data, aes(unemployed, highest_quali))
p + geom_point(aes(colour = muslim, size = black_african)) 

p2 <- ggplot(Census.Data, aes(highest_quali, employed))
p2 + geom_point(aes(colour = white, size = other_eu))

```
Looking at the first one we can see that there is a negative correlation between percentage of highest qualification within OA and the unemployment rate. Additionally OA's with more black/african people and of muslim faith are mostly the ones with highest unemployment rate. That indicates that there might be a problem in employment opportunities and education for immigrants. 

On the second one the correlation between being employment rate and percentage of inhabitants with highest qualification is rather positive. However, what is interesting is that OA's with the most qualified and highest employment rate are also the ones with the most white people from european countries other than United Kingdom. That might raise suspicion, that there might be racial problem for immigrants - it is far easier for you to get education and employment if you are white. One would argue that many students from across Europe aspire to study/work in London, so this might also create the bias. However this thesis is not supported by gathered data.

Correlation plot:
```{r correlation, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

# Correlation plot

M<-cor(Census.Data[,-1])
corrplot(M, type="upper", order="hclust",
         col=brewer.pal(n=8, name="RdYlBu"))
```
Variables that we expected to be correlated with each other matched the expectations. Most of the non-white non-native OA's are also the ones with most social rented flats, biggest unemployment rate and with lowest qualification.


```{r var_maps, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

# Maps with filling 
tmap_mode("view")

tm_shape(OA.Census) + tm_fill("highest_quali", palette = "Purples", style = "quantile",
                              title = "% with a highest Qualifications") + tm_borders(alpha=.4)

tm_shape(OA.Census) + tm_fill("black_african", palette = "YlGn", style = "quantile",
                              title = "% of Black/African") + tm_borders(alpha=.4)

tm_shape(OA.Census) + tm_fill("white", palette = "GnBu", style = "quantile",
                              title = "% of Muslim") + tm_borders(alpha=.4)
```

```{r price_var_maps, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

# Plot maps with house prices and variables
tm_shape(OA.Census) + tm_fill("white", palette = "Greens",
                              style = "quantile", title = "% Whites") +
  tm_borders(alpha=.4) +
  tm_shape(House.Points) + tm_bubbles(col = "price_paid", size = 0.2,
                                      palette = "Blues", style = "quantile",
                                      legend.size.show = FALSE,
                                      title.col = "Price Paid (£)",
                                      border.col = "black", border.lwd = 0.1,
                                      border.alpha = 0.1) +
  tm_layout(legend.text.size = 0.8, legend.title.size = 1.1, frame = FALSE)


tm_shape(OA.Census) + tm_fill("unemployed", palette = "Oranges",
                              style = "quantile", title = "% Unemployed") +
  tm_borders(alpha=.4) +
  tm_shape(House.Points) + tm_bubbles(col = "price_paid", size = 0.2,
                                      palette = "Blues", style = "quantile",
                                      legend.size.show = FALSE,
                                      title.col = "Price Paid (£)",
                                      border.col = "black", border.lwd = 0.1,
                                      border.alpha = 0.1) +
  tm_layout(legend.text.size = 0.8, legend.title.size = 1.1, frame = FALSE)

```

```{r load_kernels, echo=FALSE, warning=FALSE, message=FALSE}

kde.output <- kernelUD(House.Points, h="href", grid = 1000)
kde <- raster(kde.output)
projection(kde) <- CRS("+init=EPSG:27700")
tmap_mode("plot")
bounding_box <- bbox(Output.Areas)
masked_kde <- mask(kde, Output.Areas)
```

```{r kernel_density, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8}

tm_shape(masked_kde, bbox = bounding_box) + tm_raster("ud", style = "quantile",
                                                      n = 100,
                                                      legend.show = FALSE,
                                                      palette = "YlGnBu") +
  tm_shape(Output.Areas) + tm_borders(alpha=.3, col = "white") +
  tm_layout(frame = FALSE) 

range75 <- getverticeshr(kde.output, percent = 75)
range50 <- getverticeshr(kde.output, percent = 50)
range25 <- getverticeshr(kde.output, percent = 25)

tm_shape(Output.Areas) + tm_fill(col = "#f0f0f0") + tm_borders(alpha=.8, col = "white") +
  tm_shape(House.Points) + tm_dots(col = "blue") +
  tm_shape(range75) + tm_borders(alpha=.7, col = "#fb6a4a", lwd = 2) +
tm_fill(alpha=.1, col = "#fb6a4a") +
  tm_shape(range50) + tm_borders(alpha=.7, col = "#de2d26", lwd = 2) +
  tm_fill(alpha=.1, col = "#de2d26") +
  tm_shape(range25) + tm_borders(alpha=.7, col = "#a50f15", lwd = 2) +
  tm_fill(alpha=.1, col = "#a50f15") +
  tm_layout(frame = FALSE)

```

## Model part (practical?)

In this part we are going to focus our study on the causes of the size of the *employed* indicator as well as the *housing prices* in the Royal Borough of Kensington and Chelsea.

Firstly, we need to compute polygons for our dataset, which we are going to use in later parts of the study. Doing this in two different ways results in:

```{r neighbours, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# ------------------- Finding neighbours -------------------

neighbours <- poly2nb(OA.Census)
neighbours2 <- poly2nb(OA.Census, queen = FALSE)

plot(OA.Census, border = 'lightgrey')
plot(neighbours, coordinates(OA.Census), add=TRUE, col='blue')
plot(neighbours2, coordinates(OA.Census), add=TRUE, col='red')
```

## Global Spatial Autocorrelation

Having the neighbours computed, we can ran Moran's test, which will result in correlation score for our employed variable.

Moran I Test:
```{r global_autocorr, echo=FALSE, warning=FALSE}

# ------------------- Running a global spatial autocorrelation -------------------
listw <- nb2listw(neighbours2)
moran.test(OA.Census$employed, listw)
```

Employed indicator has 0.34 Moran's I statistic so it has a slight positive autocorrelation. Now, we have reasons to believe that the data does spatially cluster.

## Local Spatial Autocorrelation

Analysis of the local spatial autocorrelation may result in broader conclusions. 

Below, you can observe local moran statistic on our map broken down by OA:

```{r local_autocorr, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# ------------------- Running a local spatial autocorrelation -------------------

# creates a local moran output
local <- localmoran(x = OA.Census$employed,
                    listw = nb2listw(neighbours2, style = "W"))
moran.map <- cbind(OA.Census, local)
tm_shape(moran.map) + tm_fill(col = "Ii", style = "quantile", palette = "GnBu", title = "local moran statistic") + tm_layout(frame = FALSE)

```

We can clearly see, that there are indeed areas, which are surrounded by units with similar values - those with positive local moran statistic. This further confirms that the data spatially cluster. However, this map does not bring us the information about those areas/clusters.

To get the insights of each are, we are going to utilize LISA cluster map.

## LISA cluster map

We set the level of significance to 0.2 for quality visualizations.
```{r lisa, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# -------------------  to create LISA cluster map ------------------- 

quadrant <- vector(mode="numeric",length=nrow(local))
# centers the variable of interest around its mean
m.employed <- OA.Census$employed - mean(OA.Census$employed)
# centers the local Moran's around the mean
m.local <- local[,1] - mean(local[,1])
# significance threshold
signif <- 0.2
# builds a data quadrant
quadrant[m.employed >0 & m.local>0] <- 4
quadrant[m.employed <0 & m.local<0] <- 1
quadrant[m.employed <0 & m.local>0] <- 2
quadrant[m.employed >0 & m.local<0] <- 3
quadrant[local[,5]>signif] <- 0

# plot in r
brks <- c(0,1,2,3,4)
colors <- c("white","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
plot(OA.Census,border="lightgray",col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
legend("bottomleft",legend=c("insignificant","low-low","low-high","high-low","high-high"),
       fill=colors,bty="n")
```
We can now observe, which clusters are of high and which of low values. North areas of Kensington border with areas of low values, while some of the Chelsea's areas border with high values, even though these are in the center of Chelsea. We can conclude, that the data is significantly clustered in means of employment.


## GETIS-ORD

We can also check whether the Getis-Ord Gi statistic can help us with our analysis. Thanks to that we can broaden our analysis with proximity based neighbours instead of border based.

We set the proximity to 1000 and observe hot-spots on the map below:
```{r getis_ord, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# -------------------  GETIS-ORD ------------------- 

# creates centroid and joins neighbours within 0 and x units
nb <- dnearneigh(coordinates(OA.Census),0,1000)
nb_lw <- nb2listw(nb, style = 'B')


# compute Getis-Ord Gi statistic - NOT WORKING
local_g <- localG(OA.Census$employed, nb_lw)
local_g <- cbind(OA.Census, as.matrix(local_g))
names(local_g)[58] <- "gstat"

tm_shape(local_g) + tm_fill("gstat", palette = "RdBu", style = "pretty") +
  tm_borders(alpha=.4) + tm_layout(frame = FALSE)
```
We can clearly see that there are three main cluster:
- of low values in the north
- of high values in the center
- of slightly high values in the south


## Linear model - employed
Using backward variables selection we eliminated most of the insignificant variables and came up with following model:
```{r linear_model, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# -------------------  LINEAR MODEL ------------------- 

sig_cols_2 <- c('white', 'black_african', 'single', 'lowest_quali','highest_quali')
model_sig_2 <- lm(OA.Census$employed ~ .-1, data = OA.Census[,sig_cols_2])
summary(model_sig_2)

par(mfrow=c(2,2))
plot(model_sig_2)
```


```{r linear_model_resids, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}
resids<-residuals(model_sig_2)
map.resids <- cbind(OA.Census, resids)
names(map.resids)[58] <- "resids"

tm_shape(map.resids) + tm_fill("resids", palette="Blues") + tm_borders(alpha=.4) + tm_layout(frame = FALSE)
```

## GWR - employed
```{r gwr, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# ------------------- GWR ------------------- 

#calculate kernel bandwidth
GWRbandwidth <- gwr.sel(OA.Census$employed ~ .-1, data = OA.Census[,sig_cols_2], adapt =TRUE)


gwr.model = gwr(OA.Census$employed ~ .-1,
                data = OA.Census[,sig_cols_2], adapt=GWRbandwidth, hatmatrix=TRUE, se.fit=TRUE)
#print the results of the model
gwr.model
```

```{r gwr_results, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}
results <-as.data.frame(gwr.model$SDF)
gwr.map <- cbind(OA.Census[,sig_cols_2], as.matrix(results))

tm_shape(gwr.map) + tm_fill("localR2", palette="PuBuGn")+ tm_borders(alpha=.4) + tm_layout(frame = FALSE)
# qtm(gwr.map, fill = "localR2", palette="PuBuGn")

# create tmap objects
map1 <- tm_shape(gwr.map) + tm_fill("white", n = 5, style = "quantile", palette="Blues",
                                    title = "white") +
 tm_layout(frame = FALSE)
map2 <- tm_shape(gwr.map) + tm_fill("white.1", n = 5, style = "quantile", palette="Greens",
                                    title = "white coefficient") +
  tm_layout(frame = FALSE)
map3 <- tm_shape(gwr.map) + tm_fill("black_african", n = 5, style = "quantile", palette="Blues",
                                    title = "black") +
  tm_layout(frame = FALSE)
map4 <- tm_shape(gwr.map) + tm_fill("black_african.1", n = 5, style = "quantile", palette="Greens",
                                    title = "black coefficient") +
  tm_layout(frame = FALSE)
map5 <- tm_shape(gwr.map) + tm_fill("single", n = 5, style = "quantile", palette="Blues",
                                    title = "single") +
  tm_layout(frame = FALSE)
map6 <- tm_shape(gwr.map) + tm_fill("single.1", n = 5, style = "quantile", palette="Greens",
                                    title = "single coefficient") +
  tm_layout(frame = FALSE)
map7 <- tm_shape(gwr.map) + tm_fill("lowest_quali", n = 5, style = "quantile", palette="Blues",
                                    title = "lowest qualifications") +
  tm_layout(frame = FALSE)
map8 <- tm_shape(gwr.map) + tm_fill("lowest_quali.1", n = 5, style = "quantile", palette="Greens",
                                    title = "lowest qualifications coefficient") +
  tm_layout(frame = FALSE)
map9 <- tm_shape(gwr.map) + tm_fill("highest_quali", n = 5, style = "quantile", palette="Blues",
                                    title = "highest qualifications") +
  tm_layout(frame = FALSE)
map10 <- tm_shape(gwr.map) + tm_fill("highest_quali.1", n = 5, style = "quantile", palette="Greens",
                                    title = "highest qualifications coefficient") +
  tm_layout(frame = FALSE)

# --- FIRST 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map1, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map2, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map3, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map4, vp=viewport(layout.pos.col = 2, layout.pos.row =2))

# --- SECOND 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map5, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map6, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map7, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map8, vp=viewport(layout.pos.col = 2, layout.pos.row =2))

# --- LAST VARIABLE
grid.newpage()
pushViewport(viewport(layout=grid.layout(1,2)))
print(map9, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map10, vp=viewport(layout.pos.col = 2, layout.pos.row =1))

```


## LINEAR MODEL - PRICES

```{r linear_price, echo=FALSE, warning=FALSE}

# -------------------  LINEAR MODEL - PRICE ------------------- 
sig_cols <- c( 'single', 'muslim','highest_quali', 'jewish', 'asian', 'one_car', 'no_cars',
               'Age_30_44', 'employed', 'private_rent')
model_sig <- lm(OA.Census.mp$mean_price ~ ., data = OA.Census.mp[sig_cols])
summary(model_sig)

```

```{r linear_price_resids, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}
# plot resids
resids<-residuals(model_sig)
map.resids <- cbind(OA.Census.mp, resids)
names(map.resids)[58] <- "resids"
tm_shape(map.resids) + tm_fill("resids", palette="Blues") + tm_borders(alpha=.4) + tm_layout(frame = FALSE)
```

## GWR - PRICES
```{r gwr_price, echo=FALSE, warning=FALSE}

# ------------------- GWR - PRICE ------------------- 

#calculate kernel bandwidth
GWRbandwidth <- gwr.sel(OA.Census.mp$mean_price ~ ., data = OA.Census.mp[,sig_cols], adapt =TRUE)


gwr.model = gwr(OA.Census.mp$mean_price ~ .,
                data = OA.Census.mp[,sig_cols], adapt=GWRbandwidth, hatmatrix=TRUE, se.fit=TRUE)
#print the results of the model
gwr.model

```

```{r gwr_price_results, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

results <-as.data.frame(gwr.model$SDF)
gwr.map <- cbind(OA.Census.mp[,sig_cols], as.matrix(results))
tm_shape(gwr.map) + tm_fill("localR2", palette="PuBuGn")+ tm_borders(alpha=.4) + tm_layout(frame = FALSE)

# create tmap objects
map1 <- tm_shape(gwr.map) + tm_fill("single", n = 5, style = "quantile", palette="Greens",
                                    title = "single") +
  tm_layout(frame = FALSE)
map2 <- tm_shape(gwr.map) + tm_fill("single.1", n = 5, style = "quantile", palette="Blues",
                                    title = "single coefficient") +
  tm_layout(frame = FALSE)
map3 <- tm_shape(gwr.map) + tm_fill("muslim", n = 5, style = "quantile", palette="Greens",
                                    title = "muslim") +
  tm_layout(frame = FALSE)
map4 <- tm_shape(gwr.map) + tm_fill("muslim.1", n = 5, style = "quantile", palette="Blues",
                                    title = "muslim coefficient") +
  tm_layout(frame = FALSE)

map5 <- tm_shape(gwr.map) + tm_fill("jewish", n = 5, style = "quantile", palette="Greens",
                                    title = "jewish") +
  tm_layout(frame = FALSE)
map6 <- tm_shape(gwr.map) + tm_fill("jewish.1", n = 5, style = "quantile", palette="Blues",
                                    title = "jewish coefficient") +
  tm_layout(frame = FALSE)
map7 <- tm_shape(gwr.map) + tm_fill("asian", n = 5, style = "quantile", palette="Greens",
                                    title = "asian") +
  tm_layout(frame = FALSE)
map8 <- tm_shape(gwr.map) + tm_fill("asian.1", n = 5, style = "quantile", palette="Blues",
                                    title = "asian coefficient") +
  tm_layout(frame = FALSE)
map9 <- tm_shape(gwr.map) + tm_fill("one_car", n = 5, style = "quantile", palette="Greens",
                                    title = "one_car") +
  tm_layout(frame = FALSE)
map10 <- tm_shape(gwr.map) + tm_fill("one_car.1", n = 5, style = "quantile", palette="Blues",
                                     title = "one_car coefficient") +
  tm_layout(frame = FALSE)

map11 <- tm_shape(gwr.map) + tm_fill("no_cars", n = 5, style = "quantile", palette="Greens",
                                    title = "no_cars") +
  tm_layout(frame = FALSE)
map12 <- tm_shape(gwr.map) + tm_fill("no_cars.1", n = 5, style = "quantile", palette="Blues",
                                    title = "no_cars coefficient") +
  tm_layout(frame = FALSE)
map13 <- tm_shape(gwr.map) + tm_fill("Age_30_44", n = 5, style = "quantile", palette="Greens",
                                     title = "Age_30_44") +
  tm_layout(frame = FALSE)
map14 <- tm_shape(gwr.map) + tm_fill("Age_30_44.1", n = 5, style = "quantile", palette="Blues",
                                     title = "Age_30_44 coefficient") +
  tm_layout(frame = FALSE)
map15 <- tm_shape(gwr.map) + tm_fill("employed", n = 5, style = "quantile", palette="Greens",
                                     title = "employed") +
  tm_layout(frame = FALSE)
map16 <- tm_shape(gwr.map) + tm_fill("employed.1", n = 5, style = "quantile", palette="Blues",
                                     title = "employed coefficient") +
  tm_layout(frame = FALSE)
map17 <- tm_shape(gwr.map) + tm_fill("private_rent", n = 5, style = "quantile", palette="Greens",
                                     title = "private_rent") +
  tm_layout(frame = FALSE)
map18 <- tm_shape(gwr.map) + tm_fill("private_rent.1", n = 5, style = "quantile", palette="Blues",
                                     title = "private_rent coefficient") +
  tm_layout(frame = FALSE)
map19 <- tm_shape(gwr.map) + tm_fill("highest_quali", n = 5, style = "quantile", palette="Greens",
                                     title = "highest_quali") +
  tm_layout(frame = FALSE)
map20 <- tm_shape(gwr.map) + tm_fill("highest_quali.1", n = 5, style = "quantile", palette="Blues",
                                     title = "highest_quali coefficient") +
  tm_layout(frame = FALSE)


# --- FIRST 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map1, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map2, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map3, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map4, vp=viewport(layout.pos.col = 2, layout.pos.row =2))

# --- SECOND 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map5, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map6, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map7, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map8, vp=viewport(layout.pos.col = 2, layout.pos.row =2))


# --- THIRD 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map9, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map10, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map11, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map12, vp=viewport(layout.pos.col = 2, layout.pos.row =2))

# --- FOURTH 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map13, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map14, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map15, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map16, vp=viewport(layout.pos.col = 2, layout.pos.row =2))

# --- FIFTH 2 VARIABLES
grid.newpage()
pushViewport(viewport(layout=grid.layout(2,2)))
print(map17, vp=viewport(layout.pos.col = 1, layout.pos.row =1))
print(map18, vp=viewport(layout.pos.col = 2, layout.pos.row =1))
print(map19, vp=viewport(layout.pos.col = 1, layout.pos.row =2))
print(map20, vp=viewport(layout.pos.col = 2, layout.pos.row =2))
```


## Interpolation

```{r interpolation, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8}

# ------------------- Interpolation ------------------- 

# Create a tessellated surface
dat.pp <- as(dirichlet(as.ppp(House.Points)), "SpatialPolygons")
dat.pp <- as(dat.pp,"SpatialPolygons")
# Sets the projection to British National Grid
proj4string(dat.pp) <- CRS("+init=EPSG:27700")
proj4string(House.Points) <- CRS("+init=EPSG:27700")
# Assign to each polygon the data from House.Points
int.Z <- over(dat.pp,House.Points, fn=mean)
# Create a SpatialPolygonsDataFrame
thiessen <- SpatialPolygonsDataFrame(dat.pp, int.Z)
thiessen.crop <-crop(thiessen, Output.Areas)

# maps house prices across thiessen polygons
tm_shape(thiessen.crop) + tm_fill(col = "price_paid", style = "quantile", palette = "Blues",
                                  title = "Price Paid (£)") +
  tm_borders(alpha=.3, col = "black") +
  tm_shape(House.Points) + tm_dots(col = "black") +
  tm_layout(legend.position = c("left", "bottom"), legend.text.size = 1.05,
            legend.title.size = 1.2, frame = FALSE)
```

## Inverse distance weighting

```{r idw, echo=FALSE, warning=FALSE}

# ------------------- Inverse distance weighting ------------------- 

# define sample grid based on the extent of the House.Points file
grid <-spsample(House.Points, type = 'regular', n = 10000)
# runs the idw for the Price variable of House.Points
idw <- idw(House.Points$price_paid ~ 1, House.Points, newdata= grid)

idw.output = as.data.frame(idw)
names(idw.output)[1:3] <- c("long", "lat", "prediction")


spg <- idw.output
coordinates(spg) <- ~ long + lat
# coerce to SpatialPixelsDataFrame
gridded(spg) <- TRUE
# coerce to raster
raster_idw <- raster(spg)
# sets projection to British National Grid
projection(raster_idw) <- CRS("+init=EPSG:27700")
# we can quickly plot the raster to check its okay
# plot(raster_idw)
```

## 3D PLOTTING
```{r 3dplots, echo=FALSE, warning=FALSE, fig.height=8, fig.width=8, message=FALSE}

# ------------------- 3D PLOTTING ------------------- 
persp(raster_idw)

idw2 <- as.matrix(raster_idw)
persp3d(idw2, col = "red")

# masks our raster by our output areas polygon file
masked_idw <- mask(raster_idw, Output.Areas)
# plots the masked raster
tm_shape(masked_idw) + tm_raster("prediction", style = "quantile", n = 100,
                                 legend.show = FALSE) +
  tm_shape(House.Points) + tm_bubbles(size = "price_paid", col = "price_paid",
                                      palette = "Blues", style = "quantile",
                                      legend.size.show = FALSE,
                                      title.col = "Price Paid (£)") +
  tm_layout(legend.position = c("left", "bottom"), legend.text.size = 1.1,
            legend.title.size = 1.4, frame = FALSE)
```

## Geostatistical interpolation
```{r geo_interpolation, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
# ------------------- Geostatistical interpolation ------------------- 
grid <-spsample(House.Points, type = 'regular', n = 10000)
# runs the kriging
kriging_result = autoKrige(log(price_paid)~1, House.Points, grid)
```
```{r geo_interpolation_plot, echo=FALSE, warning=FALSE, message=FALSE, fig.height=8, fig.width=8,}
plot(kriging_result)
```



